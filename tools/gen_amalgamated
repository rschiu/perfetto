#!/usr/bin/env python
# Copyright (C) 2019 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This tool uses a collection of BUILD.gn files and build targets to generate
# an "amalgamated" C++ header and source pair which compiles to an equivalent
# program. The input to the tool is a JSON description of the GN build
# definition generated with the following command:
#
#   gn desc out --format=json --all-toolchains "//*" > desc.json
#
# The tool also ensures the header file sets the necessary build time flags to
# match the GN build and prints a list of linker flags needed by the resulting
# source file.

import argparse
import errno
import json
import os
import re
import shutil
import subprocess
import sys

# Default targets to include in the result.
default_targets = [
    '//:libperfetto',
]

# Arguments for the GN output directory.
gn_args = 'target_cpu="x86" is_debug=false'

# Compiler flags which are filtered out.
cflag_blacklist = r'^-(nostdinc[+][+]|isystem[^ ].*|fno-rtti)$'

# Libraries which are filtered out.
lib_blacklist = r'^(c|gcc_eh)$'

# Macros which aren't filtered out.
define_whitelist = r'^PERFETTO.*$'

# Include files which will be never attemped to expanded into the amalgamated
# header. TODO(skyostil): Fix the includes so this isn't needed.
include_blacklist = r'^(google/protobuf|gtest).*$'

# A mapping of dependencies to system libraries. Libraries in this map will not
# be built statically but instead added as dependencies of the amalgamated
# project.
system_library_map = {
    '//buildtools:gmock': 'gmock',
    '//buildtools:gtest': 'gtest',
    '//buildtools:gtest_main': 'gtest_main',
    '//buildtools:protobuf_full': 'protobuf',
    '//buildtools:protobuf_lite': 'protobuf-lite',
    '//buildtools:protoc_lib': 'protoc',
    '//gn:gtest_prod_config': 'gtest',
}

# ----------------------------------------------------------------------------
# End of configuration.
# ----------------------------------------------------------------------------

preamble = """// Copyright (C) 2019 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file is automatically generated by %s. Do not edit.
""" % (__file__)


def apply_blacklist(blacklist, items):
    return [item for item in items if not re.match(blacklist, item)]


def apply_whitelist(whitelist, items):
    return [item for item in items if re.match(whitelist, item)]


class DependencyNode(object):
    def __init__(self, target_name):
        self.target_name = target_name
        self.dependencies = set()

    def add_dependency(self, target_node):
        if target_node in self.dependencies:
            return
        self.dependencies.add(target_node)

    def iterate_depth_first(self):
        for node in sorted(self.dependencies, key=lambda n: n.target_name):
            for node in node.iterate_depth_first():
                yield node
        if self.target_name:
            yield self


class DependencyTree(object):
    def __init__(self):
        self.target_to_node_map = {}
        self.root = self._get_or_create_node(None)

    def _get_or_create_node(self, target_name):
        if target_name in self.target_to_node_map:
            return self.target_to_node_map[target_name]
        node = DependencyNode(target_name)
        self.target_to_node_map[target_name] = node
        return node

    def add_dependency(self, from_target, to_target):
        from_node = self._get_or_create_node(from_target)
        to_node = self._get_or_create_node(to_target)
        assert from_node is not to_node
        from_node.add_dependency(to_node)

    def iterate_depth_first(self):
        for node in self.root.iterate_depth_first():
            yield node


class AmalgamatedProject(object):
    """In-memory representation of an amalgamated source/header pair."""

    def __init__(self, desc):
        self.desc = desc
        self.header = []
        self.source = []
        self.dependency_tree = DependencyTree()
        self.included_headers = set()
        self.include_re = re.compile(r'#include "(.*)"')
        self.cflags = set()  # Note that we don't support multi-arg flags.
        self.ldflags = set()
        self.defines = set()
        self.libs = set()

    def add_target(self, target_name):
        self.dependency_tree.add_dependency(None, target_name)
        self._add_target_dependencies(target_name)
        self._add_target_flags(target_name)

    def _iterate_dep_edges(self, target_name):
        target = self.desc[target_name]
        for dep in target.get('deps', []):
            # Ignore system libraries since they will be added as build-time
            # dependencies.
            if dep in system_library_map:
                continue
            # Don't descend into build action dependencies.
            if self.desc[dep]['type'] == 'action':
                continue
            for sub_target, sub_dep in self._iterate_dep_edges(dep):
                yield sub_target, sub_dep
            yield target_name, dep

    def _iterate_target_and_deps(self, target_name):
        yield target_name
        for _, dep in self._iterate_dep_edges(target_name):
            yield dep

    def _add_target_dependencies(self, target_name):
        for target, dep in self._iterate_dep_edges(target_name):
            self.dependency_tree.add_dependency(target, dep)

        def iterate_all_deps(target_name):
            target = self.desc[target_name]
            for dep in target.get('deps', []):
                for sub_dep in iterate_all_deps(dep):
                    yield sub_dep
                yield dep

        for dep in iterate_all_deps(target_name):
            if dep in system_library_map:
                self.libs.add(system_library_map[dep])

    def _filter_cflags(self, cflags):
        skip_next = False
        cflags = apply_blacklist(cflag_blacklist, cflags)
        for flag in cflags:
            if flag == '-isystem':
                skip_next = True
            elif not skip_next:
                # We don't support any other multi-arg flags than -isystem.
                assert flag.startswith('-')
                yield flag
            else:
                skip_next = False

    def _add_target_flags(self, target_name):
        for target_name in self._iterate_target_and_deps(target_name):
            target = self.desc[target_name]
            self.cflags.update(self._filter_cflags(target.get('cflags', [])))
            self.cflags.update(self._filter_cflags(target.get('cflags_cc', [])))
            self.ldflags.update(target.get('ldflags', []))
            self.libs.update(
                apply_blacklist(lib_blacklist, target.get('libs', [])))
            self.defines.update(
                apply_whitelist(define_whitelist, target.get('defines', [])))

    def _get_include_dirs(self, target_name):
        include_dirs = set()
        for target_name in self._iterate_target_and_deps(target_name):
            target = self.desc[target_name]
            if 'include_dirs' in target:
                include_dirs.update(
                    [label_to_path(d) for d in target['include_dirs']])
        return include_dirs

    def _add_header(self, include_dirs, header_name):
        if header_name in self.included_headers:
            return
        self.included_headers.add(header_name)
        for include_dir in include_dirs:
            full_path = os.path.join(include_dir, header_name)
            if os.path.exists(full_path):
                with open(full_path) as f:
                    self.header.extend(self._process_includes(include_dirs, f))
                return
        msg = 'Looked in %s' % ', '.join('"%s"' % d for d in include_dirs)
        raise RuntimeError('Header file %s not found. %s' % (header_name, msg))

    def _add_source(self, target_name, source_name):
        include_dirs = self._get_include_dirs(target_name)
        if not os.path.exists(source_name):
            raise RuntimeError('Source file %s not found' % source_name)
        with open(source_name) as f:
            self.source.extend(self._process_includes(include_dirs, f))

    def _process_includes(self, include_dirs, file):
        result = []
        for line in file:
            m = self.include_re.match(line)
            if m and not re.match(include_blacklist, m.group(1)):
                self._add_header(include_dirs, m.group(1))
            else:
                result.append(line.rstrip('\n'))
        return result

    def generate(self):
        source_files = []
        for node in self.dependency_tree.iterate_depth_first():
            target = self.desc[node.target_name]
            if not 'sources' in target:
                continue
            sources = [(node.target_name, label_to_path(s))
                        for s in target['sources'] if s.endswith('.cc')]
            source_files.extend(sources)
        for target_name, source_name in source_files:
            self._add_source(target_name, source_name)

    def save(self, output_prefix):
        basename = os.path.basename(output_prefix)
        with open(output_prefix + '.h', 'w') as f:
            f.write('\n'.join([preamble] + self.header))
        with open(output_prefix + '.cc', 'w') as f:
            include_stmt = '#include "%s.h"' % basename
            f.write('\n'.join([preamble, include_stmt] + self.source))

        nice_path = os.path.join(
            os.path.relpath(os.path.dirname(output_prefix)), basename)

        build_cmd = ['clang++', '%s.cc' % nice_path, '-o', nice_path] + \
            sorted(self.cflags) + sorted(self.ldflags)
        for lib in sorted(self.libs):
            build_cmd.append('-l%s' % lib)
        for define in sorted(self.defines):
            build_cmd.append('-D%s' % define)

        return """Amalgamated project written to %s.h and %s.cc.

Build settings:
 - cflags:  %s
 - ldflags: %s
 - libs:    %s
 - defines: %s

Example build command:

%s
""" % (nice_path, nice_path, ' '.join(self.cflags), ' '.join(self.ldflags),
       ' '.join(self.libs), ' '.join(self.defines), ' '.join(build_cmd))


def label_to_path(label):
    """Turn a GN output label (e.g., //some_dir/file.cc) into a path."""
    assert label.startswith('//')
    return label[2:]


def create_amalgamated_project_for_targets(desc, targets):
    """Generate an amalgamated project for a list of GN targets."""
    project = AmalgamatedProject(desc)
    for target in targets:
        project.add_target(target)
    project.generate()
    return project


def repo_root():
    """Returns an absolute path to the repository root."""

    return os.path.join(
        os.path.realpath(os.path.dirname(__file__)), os.path.pardir)


def build_targets(out, targets):
    """Runs ninja to build a list of GN targets in the given out directory.

    Compiling these targets is required so that we can include any generated
    source files in the amalgamated result.
    """
    targets = [t.replace('//', '') for t in targets]
    subprocess.check_call(['ninja'] + targets, cwd=out)


def prepare_out_directory():
    """Creates the JSON build description by running GN.

    Returns (path, desc) where |path| is the location of the output directory
    and |desc| is the JSON build description.
    """

    out = os.path.join(repo_root(), 'out', 'tmp.gen_amalgamated')
    try:
        os.makedirs(out)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    subprocess.check_output(
        ['gn', 'gen', out, '--args=%s' % gn_args], cwd=repo_root())
    desc = subprocess.check_output(
        ['gn', 'desc', out, '--format=json', '--all-toolchains', '//*'],
        cwd=repo_root())
    return out, json.loads(desc)


def main():
    parser = argparse.ArgumentParser(
        description='Generate an amalgamated header/source from a GN '
                    'build description.')
    parser.add_argument(
        '--output',
        help='Base name of files to create. A .cc/.h extension will be added',
        default=os.path.join(repo_root(), 'perfetto'),
    )
    parser.add_argument(
        'targets',
        nargs=argparse.REMAINDER,
        help='Targets to include in the output (e.g., "//:libperfetto")')
    args = parser.parse_args()
    targets = args.targets or default_targets

    try:
        out, desc = prepare_out_directory()
        with open("desc.json", "w") as f:
            f.write(json.dumps(desc))
        build_targets(out, targets)
        project = create_amalgamated_project_for_targets(desc, targets)
        print project.save(args.output)
    finally:
        pass
        #shutil.rmtree(out)

if __name__ == '__main__':
    sys.exit(main())
